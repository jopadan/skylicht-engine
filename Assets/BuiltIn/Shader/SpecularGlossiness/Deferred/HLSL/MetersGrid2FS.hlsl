// File Generated by Assets/BuildShader.py - source: [MetersGridFS.d.hlsl : CUSTOM_COLOR]
struct PS_INPUT
{
	float4 pos : SV_POSITION;
	float2 tex0 : TEXCOORD0;
	float4 worldPosition: WORLDPOSITION;
	float3 worldNormal: WORLDNORMAL;
};
struct PS_OUTPUT
{
	float4 Diffuse: SV_TARGET0;
	float4 Position: SV_TARGET1;
	float4 Normal: SV_TARGET2;
	float4 SG: SV_TARGET3;
};
cbuffer cbPerFrame
{
	float4 uColor;
	float2 uSpecGloss;
	float4 uLightColor;
	float4 uDarkColor;
	float4 uBorderColor;
};
static const float gridSize = 4.0;
static float border = gridSize / 200.0;
float gridBorder(float3 uv3, float borderWidth, float aa)
{
	float2 uv = uv3.xz + uv3.xy + uv3.yz;
	float2 dx = ddx(uv);
	float2 dy = ddy(uv);
	float4 uvDDXY = float4(dx, dy);
	float2 uvDeriv = float2(length(uvDDXY.xz), length(uvDDXY.yw));
	float2 targetWidth = float2(borderWidth, borderWidth);
	float2 lineAA = uvDeriv * 1.5 * aa;
	float2 gridUV = float2(1.0, 1.0) - abs(frac(uv3.xz) * 2.0 - float2(1.0, 1.0));
	float2 drawWidth = clamp(targetWidth, uvDeriv, 1.0);
	float2 gridBase = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);
	float2 greyScale = clamp(targetWidth / drawWidth, 0.0, 1.0);
	gridBase *= greyScale;
	return lerp(gridBase.x, 1.0, gridBase.y);
}
PS_OUTPUT main(PS_INPUT input)
{
	PS_OUTPUT output;
	float3 pos = input.worldPosition.xyz;
	float3 uv = pos / gridSize;
	float grid = gridBorder(uv, border, 1.0);
	pos.x = pos.x + gridSize / 2;
	pos.z = pos.z + gridSize / 2;
	uv = pos / (gridSize * 2);
	float checkerBoard = gridBorder(uv, 0.5, 1.5);
	float3 col = lerp(uLightColor.rgb, uDarkColor.rgb, checkerBoard);
	col = lerp(col, uBorderColor.rgb, grid);
	output.Diffuse = uColor * float4(col.r, col.g, col.b, 1.0);
	output.SG = float4(uSpecGloss.x, uSpecGloss.y, 0.0, 1.0);
	output.Position = input.worldPosition;
	output.Normal = float4(input.worldNormal, 1.0);
	return output;
}
